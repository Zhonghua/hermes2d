// This file is part of Hermes2D.
//
// Copyright 2005-2008 Jakub Cerveny <jakub.cerveny@gmail.com>
// Copyright 2005-2008 Lenka Dubcova <dubcova@gmail.com>
// Copyright 2005-2008 Pavel Solin <solin@unr.edu>
//
// Hermes2D is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 2 of the License, or
// (at your option) any later version.
//
// Hermes2D is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Hermes2D.  If not, see <http://www.gnu.org/licenses/>.

// $Id: view1.cpp 1086 2008-10-21 09:05:44Z jakub $

#ifndef NOGLUT

#include <GL/freeglut.h>
#ifndef WIN32
# include <sys/time.h>
#endif

#include "../common.h"
#include "view.h"
#include "view_support.h"


//// glut low-level stuff //////////////////////////////////////////////////////////////////////////

pthread_t thread;
static bool thread_running = false;
static bool did_init = false;

static int (*ctc_function)(void*) = NULL;
static void* ctc_param;
static int ctc_result;
static pthread_mutex_t ctc_mutex, pe_mutex;
static pthread_cond_t ctc_result_cv, pe_cv;

static const int timer_ms = 10;
static const long double_click_delay_ms = 300; // fixme: get system doubleclick time

std::vector<View*> wnd_instance;
int num_windows = 0;

/// Initializes GLUT internal structures, processes command line options
void glut_init()
{
  if (did_init) return;
  static int argc = 1;
  static const char* argv[1] = { "x" };

  glutInit(&argc, (char**) argv);
  glutInitDisplayMode(GLUT_RGBA | GLUT_DOUBLE | GLUT_ACCUM | GLUT_DEPTH);
  glutSetOption(GLUT_ACTION_ON_WINDOW_CLOSE, GLUT_ACTION_CONTINUE_EXECUTION);
  did_init = true;
}


/// This timer prevents the GLUT main loop from sleeping "too much".
/// If there are no events generated by the system (ie. the user does
/// not move the mouse), the main loop is in a wait state and does
/// not react to glutPostRedisplay() generated from other threads.
/// If there is a timer set up, the main loop only dozes for the
/// timer interval and then rushes to service the timer, servicing
/// also the redisplay request along the way.
static void wake_up_timer(int)
{
  glutTimerFunc(timer_ms, wake_up_timer, 0);
  
  // Also, this is a good place to perform a cross thread call,
  // if one is scheduled
  if (ctc_function != NULL)
  {
    pthread_mutex_lock(&ctc_mutex);
    ctc_result = ctc_function(ctc_param);
    ctc_function = NULL;
    pthread_cond_signal(&ctc_result_cv);
    pthread_mutex_unlock(&ctc_mutex);
  }
}


/// This is the GLUT main loop running in a separate thread, so
/// that the windows are responsive at all times. 
static void* main_loop_thread(void*)
{
  thread_running = true;
  //printf("entering glut main loop...\n");
  wake_up_timer(0);
  glutMainLoop();
  did_init = false;
  thread_running = false;
  //printf("exiting glut main loop...\n");
  return NULL;
}


/// Starts a separate thread running the GLUT main loop. If the thread
/// was already started, it does nothing.
static void start_glut_main_loop()
{
  if (thread_running) return;
  //printf("start_glut_main_loop()\n");
  glut_init();
  int err = pthread_create(&thread, NULL, main_loop_thread, NULL);
  thread_running = true;
  if (err) error("Failed to create GLUT main loop thread (error=%d)", err);
}


// Dummy struct for the creation and destruction of ctc_mutex and ctc_result_cv...
static struct sync_init_1
{
  sync_init_1()
  {
    pthread_mutex_init(&ctc_mutex, NULL);
    pthread_mutex_init(&pe_mutex, NULL);
    pthread_cond_init (&ctc_result_cv, NULL);
    pthread_cond_init (&pe_cv, NULL);
  }
  ~sync_init_1() 
  {
    pthread_mutex_destroy(&ctc_mutex);
    pthread_mutex_destroy(&pe_mutex);
    pthread_cond_destroy(&ctc_result_cv);
    pthread_cond_destroy(&pe_cv);
  }
}
dummy_sync_init_struct_1;


/// GLUT does not like certain functions, such as glutCreateWindow,
/// to be called from a different thread than the one running the main
/// loop. This functions causes the main loop thread to call the
/// specified function. Then it waits for its completion and returns 
/// its result.
int cross_thread_call(int (*function)(void*), void* param = NULL)
{
  pthread_mutex_lock(&ctc_mutex);
  //printf("scheduling a cross thread call...\n");
  ctc_function = function;
  ctc_param = param;
  start_glut_main_loop();
  pthread_cond_wait(&ctc_result_cv, &ctc_mutex);  
  //printf("cross thread call successful, return code %d\n", ctc_result);
  pthread_mutex_unlock(&ctc_mutex);
  return ctc_result;
}


static int glut_leave_main_loop(void*) { glutLeaveMainLoop(); return 0; }

/// Waits for the GLUT main loop thread to finish. This happens after
/// all windows are closed. To force the main loop to quit without waiting
/// for windows to close, use the \a force parameter.
void finish_glut_main_loop(bool force)
{
  if (!thread_running) return;
  if (force) cross_thread_call(glut_leave_main_loop);
  //verbose("Waiting for view windows to close...");
  pthread_join(thread, NULL);
  thread_running = false;
}


//// handler stubs /////////////////////////////////////////////////////////////////////////////////

void on_display_stub(void) 
{ 
  View* wnd = wnd_instance[glutGetWindow()];
  if (wnd != NULL) wnd->pre_display();
}

void on_reshape_stub(int width, int height)
{ 
  View* wnd = wnd_instance[glutGetWindow()];
  if (wnd != NULL) wnd->on_reshape(width, height);
}

void on_mouse_move_stub(int x, int y) 
{ 
  View* wnd = wnd_instance[glutGetWindow()];
  if (wnd != NULL) wnd->on_mouse_move(x, y);
}

void on_key_down_stub(unsigned char key, int x, int y)
{
  View* wnd = wnd_instance[glutGetWindow()];
  if (wnd != NULL) wnd->on_key_down(key, x, y);
}

void on_special_key_stub(int key, int x, int y)
{
  View* wnd = wnd_instance[glutGetWindow()];
  if (wnd != NULL) wnd->on_special_key(key, x, y);
}

void on_entry_stub(int state)
{
  View* wnd = wnd_instance[glutGetWindow()];
  if (wnd != NULL) wnd->on_entry(state);
}


void on_mouse_click_stub(int button, int state, int x, int y)
{
  View* wnd = wnd_instance[glutGetWindow()];
  if (wnd == NULL) return;

  // emulate double-click messages
  if (state == GLUT_DOWN)
  {
    static double last_tick = 0;
    double tick = View::get_tick_count();
    //if (tick < last_tick) //todo
    if (tick - last_tick < double_click_delay_ms)
    {
      if (button == GLUT_LEFT_BUTTON)
        wnd->on_left_mouse_double_click(x, y);
      else if (button == GLUT_RIGHT_BUTTON)
        wnd->on_right_mouse_double_click(x, y);
      else
        wnd->on_middle_mouse_double_click(x, y);
        
      last_tick = 0;
      return;
    }
    last_tick = tick;
  }
  
  // call proper click handler
  if (button == GLUT_LEFT_BUTTON)
  {
    if (state == GLUT_DOWN)
      wnd->on_left_mouse_down(x, y);
    else
      wnd->on_left_mouse_up(x, y);
  }
  else if (button == GLUT_RIGHT_BUTTON)
  {
    if (state == GLUT_DOWN)
      wnd->on_right_mouse_down(x, y);
    else
      wnd->on_right_mouse_up(x, y);
  }
  else
  {
    if (state == GLUT_DOWN)
      wnd->on_middle_mouse_down(x, y);
    else
      wnd->on_middle_mouse_up(x, y);
  }
}


void on_close_stub()
{
  num_windows--;
  int id = glutGetWindow();
  if (wnd_instance[id] != NULL) 
  {
    wnd_instance[id]->on_close();
    wnd_instance[id]->window_id = -1;
    wnd_instance[id] = NULL;
  }
}

#endif // NOGLUT
